name: Create Weekly Beta Branch

on:
  schedule:
    # Run at 8:00 AM UTC+8 (00:00 UTC) every Thursday
    - cron: "0 0 * * 4"
  workflow_dispatch: # Allow manual triggering if needed

env:
  CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
  CLICKUP_LIST_ID: ${{ secrets.CLICKUP_LIST_ID }}

jobs:
  create_branch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: "master"
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'

      - name: Create new branch
        id: create_branch
        run: |
          # Use more precise date formatting to avoid cross-year week issues
          YEAR=$(date +'%Y')
          WEEK=$(date +'%V')
          BRANCH_NAME="beta/sprint-$YEAR-W$WEEK-auto"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "üìÖ Branch name will be: $BRANCH_NAME"

          # Create and push the new branch
          if git ls-remote --exit-code --heads origin $BRANCH_NAME >/dev/null 2>&1; then
            echo "‚ö†Ô∏è Branch $BRANCH_NAME already exists"
            echo "branch_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ú® Branch $BRANCH_NAME does not exist. Creating it."
            git checkout -b $BRANCH_NAME
            if git push origin $BRANCH_NAME; then
              echo "‚úÖ Successfully created and pushed branch $BRANCH_NAME"
              echo "branch_exists=false" >> $GITHUB_OUTPUT
            else
              echo "::error::‚ùå Failed to push branch $BRANCH_NAME"
              exit 1
            fi
          fi

      - name: Fetch ClickUp Beta Tasks
        id: fetch_tasks
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          echo "üîç Operating on branch: $BRANCH_NAME"

          # Create cleanup function
          cleanup() {
            rm -f /tmp/clickup_response.json
          }
          trap cleanup EXIT

          # Fetch tasks from ClickUp API with better error handling
          echo "üì° Fetching tasks from ClickUp API..."

          HTTP_CODE=$(curl -w "%{http_code}" -s --max-time 30 \
            -H "Authorization: $CLICKUP_API_TOKEN" \
            -H "Content-Type: application/json" \
            -o /tmp/clickup_response.json \
            "https://api.clickup.com/api/v2/list/$CLICKUP_LIST_ID/task?statuses[]=beta")

          # Check HTTP status code
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::‚ùå ClickUp API request failed with HTTP status: $HTTP_CODE"
            if [ -f /tmp/clickup_response.json ]; then
              echo "Response content:"
              cat /tmp/clickup_response.json
            fi
            exit 1
          fi

          # Check if response is valid JSON and has no errors
          if ! jq empty /tmp/clickup_response.json 2>/dev/null; then
            echo "::error::‚ùå Invalid JSON response from ClickUp API"
            echo "Response content:"
            cat /tmp/clickup_response.json
            exit 1
          fi

          # Check for API errors in response
          if jq -e '.err' /tmp/clickup_response.json >/dev/null 2>&1; then
            ERROR_MSG=$(jq -r '.err // "Unknown API error"' /tmp/clickup_response.json)
            echo "::error::‚ùå ClickUp API returned error: $ERROR_MSG"
            exit 1
          fi

          echo "‚úÖ API Response received successfully"

          # Parse tasks and filter with explicit sorting
          TASK_BRANCH_PAIRS=$(jq -r '.tasks[] | 
            select(
              .status.status == "beta" and 
              (.custom_fields[] | select(.name == "Repository") | .value) == "cp-web-next-test" and
              (.custom_fields[] | select(.name == "Branch") | .value) != null and
              (.custom_fields[] | select(.name == "Branch") | .value) != ""
            ) | "\(.name)\t\(.custom_fields[] | select(.name == "Branch") | .value)\t\(.id)"' \
            /tmp/clickup_response.json | sort)

          if [ -z "$TASK_BRANCH_PAIRS" ]; then
            echo "‚ÑπÔ∏è No beta tasks found for cp-web-next-test repository"
            echo "has_tasks=false" >> $GITHUB_OUTPUT
          else
            TASK_COUNT=$(echo "$TASK_BRANCH_PAIRS" | wc -l)
            echo "üéØ Found $TASK_COUNT beta tasks for cp-web-next-test:"
            echo "$TASK_BRANCH_PAIRS" | while IFS=$'\t' read -r task_name branch_name task_id; do
              echo "  üìã $task_name (Branch: $branch_name)"
            done
            echo "has_tasks=true" >> $GITHUB_OUTPUT
            echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT
            # Store the paired data in outputs for next step
            echo "task_branch_pairs<<EOF" >> $GITHUB_OUTPUT
            echo "$TASK_BRANCH_PAIRS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Merge Beta Tasks
        id: merge_beta_tasks
        if: steps.fetch_tasks.outputs.has_tasks == 'true'
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          TOTAL_TASKS="${{ steps.fetch_tasks.outputs.task_count }}"
          MERGED_COUNT=0
          FAILED_TASKS=()

          echo "üöÄ Starting merge process for $TOTAL_TASKS tasks..."

          # Enhanced cleanup function for git operations
          cleanup_git() {
            git merge --abort 2>/dev/null || true
            git reset --hard HEAD 2>/dev/null || true
            git clean -fd 2>/dev/null || true
          }
          trap cleanup_git EXIT

          # Checkout the target branch
          git checkout $BRANCH_NAME
          if [ $? -ne 0 ]; then
            echo "::error::‚ùå Failed to checkout branch $BRANCH_NAME"
            exit 1
          fi

          # Get task-branch pairs from previous step output
          TASK_BRANCH_PAIRS="${{ steps.fetch_tasks.outputs.task_branch_pairs }}"

          # Process each task-branch pair
          echo "$TASK_BRANCH_PAIRS" | while IFS=$'\t' read -r task_name branch_name task_id; do
            if [ -n "$task_name" ] && [ -n "$branch_name" ]; then
              echo ""
              echo "üì¶ Processing ($((MERGED_COUNT + 1))/$TOTAL_TASKS): $task_name"
              echo "   Branch: $branch_name"
              
              # Check if branch exists remotely
              if git ls-remote --exit-code --heads origin "$branch_name" >/dev/null 2>&1; then
                echo "   ‚úÖ Branch exists remotely"
                
                # Fetch the latest version of the branch
                if git fetch origin "$branch_name" 2>/dev/null; then
                  echo "   üì• Fetched latest version"
                  
                  # Check if there are any changes to merge
                  if git merge-tree $(git merge-base HEAD "origin/$branch_name") HEAD "origin/$branch_name" | grep -q .; then
                    echo "   üîÑ Changes detected, performing squash merge..."
                    
                    # Use squash merge to keep history clean
                    if git merge "origin/$branch_name" --squash --no-edit --no-ff; then
                      # Check if there are changes to commit
                      if ! git diff --cached --quiet; then
                        git commit -m "feat: merge $branch_name - $task_name - Task ID: $task_id - Auto-merged by: GitHub Actions"
                        echo "   ‚úÖ Successfully squash merged $branch_name"
                        MERGED_COUNT=$((MERGED_COUNT + 1))
                      else
                        echo "   ‚ÑπÔ∏è No changes to commit (already up to date)"
                        MERGED_COUNT=$((MERGED_COUNT + 1))
                      fi
                    else
                      echo "   ‚ùå Merge conflict detected for $branch_name"
                      echo "::error::Merge conflict detected for task: $task_name (branch: $branch_name)"
                      cleanup_git
                      FAILED_TASKS+=("$task_name ($branch_name): Merge conflict")
                    fi
                  else
                    echo "   ‚ÑπÔ∏è No changes to merge (already up to date)"
                    MERGED_COUNT=$((MERGED_COUNT + 1))
                  fi
                else
                  echo "   ‚ùå Failed to fetch branch $branch_name"
                  FAILED_TASKS+=("$task_name ($branch_name): Failed to fetch")
                fi
              else
                echo "   ‚ùå Branch $branch_name not found remotely"
                echo "::warning::Branch not found for task: $task_name"
                FAILED_TASKS+=("$task_name ($branch_name): Branch not found")
              fi
            fi
          done

          # Generate merge summary
          echo ""
          echo "üìä Merge Summary:"
          echo "   Total tasks: $TOTAL_TASKS"
          echo "   Successfully merged: $MERGED_COUNT"
          echo "   Failed: ${#FAILED_TASKS[@]}"

          # Report failed tasks if any
          if [ ${#FAILED_TASKS[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Failed tasks:"
            printf '   %s\n' "${FAILED_TASKS[@]}"
            
            # Create summary for GitHub
            {
              echo "## Merge Summary"
              echo ""
              echo "- ‚úÖ Successfully merged: $MERGED_COUNT/$TOTAL_TASKS tasks"
              echo "- ‚ùå Failed: ${#FAILED_TASKS[@]} tasks"
              echo ""
              if [ ${#FAILED_TASKS[@]} -gt 0 ]; then
                echo "### Failed Tasks:"
                printf '- %s\n' "${FAILED_TASKS[@]}"
              fi
            } >> $GITHUB_STEP_SUMMARY
          fi

          # Push changes if any merges were successful
          if [ $MERGED_COUNT -gt 0 ]; then
            echo ""
            echo "üì§ Pushing $MERGED_COUNT successful merges..."
            if git push origin $BRANCH_NAME; then
              echo "‚úÖ Successfully pushed all changes"
              echo "merge_success=true" >> $GITHUB_OUTPUT
              echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
            else
              echo "::error::‚ùå Failed to push changes"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No changes to push"
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "merged_count=0" >> $GITHUB_OUTPUT
          fi

          # Exit with error if some tasks failed but allow partial success
          if [ ${#FAILED_TASKS[@]} -gt 0 ] && [ $MERGED_COUNT -eq 0 ]; then
            echo "::error::‚ùå All merge operations failed"
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "merged_count=0" >> $GITHUB_OUTPUT
            exit 1
          elif [ ${#FAILED_TASKS[@]} -gt 0 ]; then
            echo "::warning::‚ö†Ô∏è Some tasks failed but $MERGED_COUNT tasks were successfully merged"
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
          else
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Handle Different Scenarios
        if: always()
        run: |
          BRANCH_EXISTS="${{ steps.create_branch.outputs.branch_exists }}"
          HAS_TASKS="${{ steps.fetch_tasks.outputs.has_tasks }}"
          MERGE_SUCCESS="${{ steps.merge_beta_tasks.outputs.merge_success }}"
          MERGED_COUNT="${{ steps.merge_beta_tasks.outputs.merged_count }}"

          echo "üìã Final Status Summary:"
          echo "   Branch exists: $BRANCH_EXISTS"
          echo "   Has tasks: $HAS_TASKS"
          echo "   Merge success: $MERGE_SUCCESS"
          echo "   Merged count: $MERGED_COUNT"

          # Generate final summary
          {
            echo "## Weekly Beta Branch Creation Summary"
            echo ""
            echo "**Branch:** \`${{ steps.create_branch.outputs.branch_name }}\`"
            echo ""
            
            if [ "$BRANCH_EXISTS" = "true" ] && [ "$HAS_TASKS" = "false" ]; then
              echo "‚úÖ **Status:** Branch already exists, no new tasks to merge (normal situation)"
            elif [ "$BRANCH_EXISTS" = "false" ] && [ "$HAS_TASKS" = "false" ]; then
              echo "‚úÖ **Status:** New branch created, no tasks found (normal situation)"
            elif [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "true" ]; then
              echo "‚úÖ **Status:** Successfully merged $MERGED_COUNT tasks"
            elif [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "false" ]; then
              echo "‚ùå **Status:** Task merge failed"
            else
              echo "‚ÑπÔ∏è **Status:** Workflow completed"
            fi
            
            echo ""
            echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          } >> $GITHUB_STEP_SUMMARY

          # Only exit with error for actual failures, not expected scenarios
          if [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "false" ] && [ "${MERGED_COUNT:-0}" = "0" ]; then
            echo "::error::‚ùå Workflow failed due to merge issues"
            exit 1
          elif [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "true" ]; then
            echo "‚úÖ Workflow completed successfully with $MERGED_COUNT tasks merged"
            exit 0
          else
            echo "‚úÖ Workflow completed successfully (no tasks to merge)"
            exit 0
          fi
