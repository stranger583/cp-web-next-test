name: Create Weekly Auto Merge Branch TEST

on:
  schedule:
    # Run at 8:00 AM UTC+8 (00:00 UTC) every Thursday
    - cron: "0 0 * * 4"
  workflow_dispatch: # Allow manual triggering if needed

env:
  CLICKUP_API_TOKEN: ${{ secrets.CLICKUP_API_TOKEN }}
  CLICKUP_LIST_ID: ${{ secrets.CLICKUP_LIST_ID }}

jobs:
  create_branch:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      actions: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          ref: "master"
          fetch-depth: 0

      - name: Setup Git
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'

      - name: Create new branch
        id: create_branch
        run: |
          YEAR=$(date +'%y')
          WEEK=$(date +'%V')
          BRANCH_NAME="beta/sprint-$YEAR$WEEK-auto"
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "year=$YEAR" >> $GITHUB_OUTPUT
          echo "week=$WEEK" >> $GITHUB_OUTPUT
          echo "üìÖ Branch name will be: $BRANCH_NAME"

          # Create and push the new branch
          if git ls-remote --exit-code --heads origin $BRANCH_NAME; then
            echo "‚ö†Ô∏è Branch $BRANCH_NAME already exists"
            echo "branch_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ú® Branch $BRANCH_NAME does not exist. Creating it."
            git checkout -b $BRANCH_NAME
            git push origin $BRANCH_NAME
            echo "branch_exists=false" >> $GITHUB_OUTPUT
          fi

      - name: Fetch ClickUp Beta Tasks
        id: fetch_tasks
        run: |
          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          echo "üîç Operating on branch: $BRANCH_NAME"

          # Create cleanup function
          cleanup() {
            rm -f /tmp/clickup_response.json
          }
          trap cleanup EXIT

          # Fetch tasks from ClickUp API with error handling
          echo "üì° Fetching tasks from ClickUp API..."
          HTTP_CODE=$(curl -w "%{http_code}" -s --max-time 30 \
            -H "Authorization: $CLICKUP_API_TOKEN" \
            -H "Content-Type: application/json" \
            -o /tmp/clickup_response.json \
            "https://api.clickup.com/api/v2/list/$CLICKUP_LIST_ID/task?statuses[]=beta")

          # Check HTTP status code
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::‚ùå ClickUp API request failed with HTTP status: $HTTP_CODE"
            if [ -f /tmp/clickup_response.json ]; then
              echo "Response content:"
              cat /tmp/clickup_response.json
            fi
            exit 1
          fi

          # Check if response is valid JSON and has no errors
          if ! jq empty /tmp/clickup_response.json 2>/dev/null; then
            echo "::error::‚ùå Invalid JSON response from ClickUp API"
            echo "Response content:"
            cat /tmp/clickup_response.json
            exit 1
          fi

          echo "‚úÖ API Response received successfully"

          # Parse tasks and filter with explicit sorting
          TASK_BRANCH_PAIRS=$(jq -r '.tasks[] | 
          select(
            .status.status == "beta" and 
            (.custom_fields[] | select(.name == "Repository") | .value) == "cp-web-next-test"
          ) | 
          (.custom_fields[] | select(.name == "Branch") | .value) as $branch |
          select($branch != null and $branch != "") |
          "\(.name)\t\($branch)\t\(.id)"' \
          /tmp/clickup_response.json | sort)

          if [ -z "$TASK_BRANCH_PAIRS" ]; then
            echo "‚ÑπÔ∏è No beta tasks found for cp-web-next-test repository"
            echo "has_tasks=false" >> $GITHUB_OUTPUT
          else
            TASK_COUNT=$(echo "$TASK_BRANCH_PAIRS" | wc -l)
            echo "üéØ Found $TASK_COUNT beta tasks for cp-web-next-test:"
            echo "$TASK_BRANCH_PAIRS" | while IFS=$'\t' read -r task_name branch_name task_id; do
              echo "  üìã $task_name (Branch: $branch_name)"
            done
            echo "has_tasks=true" >> $GITHUB_OUTPUT
            echo "task_count=$TASK_COUNT" >> $GITHUB_OUTPUT
            # Store the paired data in outputs for next step
            echo "task_branch_pairs<<EOF" >> $GITHUB_OUTPUT
            echo "$TASK_BRANCH_PAIRS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Merge Beta Tasks
        id: merge_beta_tasks
        if: steps.fetch_tasks.outputs.has_tasks == 'true'
        run: |
          cleanup() {
            rm -f /tmp/tasks_to_process.txt /tmp/clickup_response.json
          }
          trap cleanup EXIT

          BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          TOTAL_TASKS="${{ steps.fetch_tasks.outputs.task_count }}"
          MERGED_COUNT=0
          FAILED_TASKS=()

          echo "üöÄ Starting merge process for $TOTAL_TASKS tasks..."

          # Enhanced cleanup function for git operations
          cleanup_git() {
            git merge --abort 2>/dev/null || true
            # Don't reset hard - it will lose previous successful merges
            # git reset --hard HEAD 2>/dev/null || true
            git clean -fd 2>/dev/null || true
          }

          # Checkout the target branch
          if ! git checkout $BRANCH_NAME; then
            echo "::error::‚ùå Failed to checkout branch $BRANCH_NAME"
            exit 1
          fi

          # Get task-branch pairs from previous step output
          TASK_BRANCH_PAIRS="${{ steps.fetch_tasks.outputs.task_branch_pairs }}"

          # Process each task-branch pair using temporary file to avoid subshell variable scope issues
          echo "$TASK_BRANCH_PAIRS" > /tmp/tasks_to_process.txt

          while IFS=$'\t' read -r task_name branch_name task_id; do
            if [ -n "$task_name" ] && [ -n "$branch_name" ]; then
              echo ""
              echo "üì¶ Processing ($((MERGED_COUNT + 1))/$TOTAL_TASKS): $task_name"
              echo "   Branch: $branch_name"
              
              # Check if branch exists remotely
              if git ls-remote --exit-code --heads origin "$branch_name" >/dev/null 2>&1; then
                echo "‚úÖ Branch exists remotely"
                
                # Fetch the latest version of the branch
                if git fetch origin "$branch_name" 2>/dev/null; then
                  echo "üì• Fetched latest version"
                  
                  # Check if there are any changes to merge
                  if git merge-tree $(git merge-base HEAD "origin/$branch_name") HEAD "origin/$branch_name" | grep -q .; then
                    echo "üîÑ Changes detected, performing squash merge..."
                    
                    # Use squash merge to keep history clean
                    echo "üîß Executing: git merge origin/$branch_name --squash --no-edit"
                    if git merge "origin/$branch_name" --squash --no-edit; then
                      echo "üîç Checking for staged changes..."
                      # Check if there are changes to commit
                      if ! git diff --cached --quiet; then
                        if git commit -m "feat: merge $branch_name"; then
                          echo "‚úÖ Successfully squash merged $branch_name"
                          MERGED_COUNT=$((MERGED_COUNT + 1))
                        else
                          echo "‚ùå Failed to commit squash merge for $branch_name"
                          cleanup_git
                          FAILED_TASKS+=("$task_name ($branch_name): Commit failed")
                        fi
                      else
                        echo "‚ÑπÔ∏è No changes to commit (already up to date)"
                        MERGED_COUNT=$((MERGED_COUNT + 1))
                      fi
                    else
                      echo "‚ùå Merge conflict detected for $branch_name"
                      echo "::error::Merge conflict detected for task: $task_name (branch: $branch_name)"
                      cleanup_git
                      FAILED_TASKS+=("$task_name ($branch_name): Merge conflict")
                    fi
                  else
                    echo "‚ÑπÔ∏è No changes to merge (already up to date)"
                    MERGED_COUNT=$((MERGED_COUNT + 1))
                  fi
                else
                  echo "‚ùå Failed to fetch branch $branch_name"
                  FAILED_TASKS+=("$task_name ($branch_name): Failed to fetch")
                fi
              else
                echo "‚ùå Branch $branch_name not found remotely"
                echo "::warning::Branch not found for task: $task_name"
                FAILED_TASKS+=("$task_name ($branch_name): Branch not found")
              fi
            fi
          done < /tmp/tasks_to_process.txt

          {
            echo "### Merge Beta Tasks Summary"
            echo "- Total tasks: $TOTAL_TASKS"
            echo "- Successfully merged: $MERGED_COUNT"
            echo "- Failed tasks: ${#FAILED_TASKS[@]}"
            if [ ${#FAILED_TASKS[@]} -gt 0 ]; then
              echo "- List of failed tasks:"
              for task in "${FAILED_TASKS[@]}"; do
                echo "  - $task"
              done
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          # Clean up temporary file
          rm -f /tmp/tasks_to_process.txt

          # Generate merge summary
          echo ""
          echo "üìä Merge Summary:"
          echo "   Total tasks: $TOTAL_TASKS"
          echo "   Successfully merged: $MERGED_COUNT"
          echo "   Failed: ${#FAILED_TASKS[@]}"

          # Report failed tasks if any
          if [ ${#FAILED_TASKS[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Failed tasks:"
            for task in "${FAILED_TASKS[@]}"; do
              echo "   $task"
            done
            
            # Create summary for GitHub
            {
              echo "## Merge Summary"
              echo ""
              echo "- ‚úÖ Successfully merged: $MERGED_COUNT/$TOTAL_TASKS tasks"
              echo "- ‚ùå Failed: ${#FAILED_TASKS[@]} tasks"
              echo ""
              if [ ${#FAILED_TASKS[@]} -gt 0 ]; then
                echo "### Failed Tasks:"
                for task in "${FAILED_TASKS[@]}"; do
                  echo "- $task"
                done
              fi
            } >> $GITHUB_STEP_SUMMARY
          fi

          # Push changes if any merges were successful
          if [ $MERGED_COUNT -gt 0 ]; then
            echo ""
            echo "üì§ Pushing $MERGED_COUNT successful merges..."
            if git push origin $BRANCH_NAME; then
              echo "‚úÖ Successfully pushed all changes"
              echo "merge_success=true" >> $GITHUB_OUTPUT
              echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
            else
              echo "::error::‚ùå Failed to push changes"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No changes to push"
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "merged_count=0" >> $GITHUB_OUTPUT
          fi

          # Check if all tasks were successfully merged (perfect scenario)
          if [ $MERGED_COUNT -eq $TOTAL_TASKS ]; then
            echo "all_tasks_merged=true" >> $GITHUB_OUTPUT
            echo "üéâ All beta tasks successfully merged!"
          else
            echo "all_tasks_merged=false" >> $GITHUB_OUTPUT
          fi

          # Exit with error if some tasks failed but allow partial success
          if [ ${#FAILED_TASKS[@]} -gt 0 ] && [ $MERGED_COUNT -eq 0 ]; then
            echo "::error::‚ùå All merge operations failed"
            echo "merge_success=false" >> $GITHUB_OUTPUT
            echo "merged_count=0" >> $GITHUB_OUTPUT
            exit 1
          elif [ ${#FAILED_TASKS[@]} -gt 0 ]; then
            echo "::warning::‚ö†Ô∏è Some tasks failed but $MERGED_COUNT tasks were successfully merged"
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
          else
            echo "merge_success=true" >> $GITHUB_OUTPUT
            echo "merged_count=$MERGED_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Create Delta Branch
        id: create_delta_branch
        if: steps.merge_beta_tasks.outputs.all_tasks_merged == 'true'
        run: |
          YEAR="${{ steps.create_branch.outputs.year }}"
          WEEK="${{ steps.create_branch.outputs.week }}"
          BETA_BRANCH_NAME="${{ steps.create_branch.outputs.branch_name }}"
          DELTA_BRANCH_NAME="delta/sprint-$YEAR$WEEK-auto"

          echo "üéØ All beta tasks successfully merged! Creating delta branch..."
          echo "   Source branch: $BETA_BRANCH_NAME"
          echo "   Delta branch: $DELTA_BRANCH_NAME"

          # Check if delta branch already exists
          if git ls-remote --exit-code --heads origin $DELTA_BRANCH_NAME; then
            echo "‚ö†Ô∏è Delta branch $DELTA_BRANCH_NAME already exists"
            echo "delta_branch_exists=true" >> $GITHUB_OUTPUT
            echo "delta_branch_created=false" >> $GITHUB_OUTPUT
          else
            echo "‚ú® Creating new delta branch: $DELTA_BRANCH_NAME"
            
            # Ensure we're on the beta branch with latest changes
            git checkout $BETA_BRANCH_NAME
            git pull origin $BETA_BRANCH_NAME
            
            # Create delta branch from beta branch
            if git checkout -b $DELTA_BRANCH_NAME; then
              echo "üì¶ Delta branch created locally"
              
              # Push delta branch to remote
              if git push origin $DELTA_BRANCH_NAME; then
                echo "üöÄ Successfully pushed delta branch to remote"
                echo "delta_branch_exists=false" >> $GITHUB_OUTPUT
                echo "delta_branch_created=true" >> $GITHUB_OUTPUT
                echo "delta_branch_name=$DELTA_BRANCH_NAME" >> $GITHUB_OUTPUT
                
                # Add to step summary
                {
                  echo "### üéâ Delta Branch Created"
                  echo "- **Branch Name:** \`$DELTA_BRANCH_NAME\`"
                  echo "- **Source:** \`$BETA_BRANCH_NAME\`"
                  echo "- **Reason:** All beta tasks successfully merged"
                  echo "- **Status:** ‚úÖ Ready for deployment"
                } >> $GITHUB_STEP_SUMMARY
              else
                echo "::error::‚ùå Failed to push delta branch to remote"
                echo "delta_branch_created=false" >> $GITHUB_OUTPUT
                exit 1
              fi
            else
              echo "::error::‚ùå Failed to create delta branch"
              echo "delta_branch_created=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          fi

      - name: Fetch ClickUp Delta Tasks
        id: fetch_delta_tasks
        if: steps.create_delta_branch.outputs.delta_branch_created == 'true' || steps.create_delta_branch.outputs.delta_branch_exists == 'true'
        run: |
          DELTA_BRANCH_NAME="${{ steps.create_delta_branch.outputs.delta_branch_name }}"
          echo "üîç Operating on delta branch: $DELTA_BRANCH_NAME"

          # Create cleanup function
          cleanup() {
            rm -f /tmp/clickup_delta_response.json
          }
          trap cleanup EXIT

          # Fetch delta tasks from ClickUp API with error handling
          echo "üì° Fetching delta tasks from ClickUp API..."
          HTTP_CODE=$(curl -w "%{http_code}" -s --max-time 30 \
            -H "Authorization: $CLICKUP_API_TOKEN" \
            -H "Content-Type: application/json" \
            -o /tmp/clickup_delta_response.json \
            "https://api.clickup.com/api/v2/list/$CLICKUP_LIST_ID/task?statuses[]=delta")

          # Check HTTP status code
          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::‚ùå ClickUp API request failed with HTTP status: $HTTP_CODE"
            if [ -f /tmp/clickup_delta_response.json ]; then
              echo "Response content:"
              cat /tmp/clickup_delta_response.json
            fi
            exit 1
          fi

          # Check if response is valid JSON and has no errors
          if ! jq empty /tmp/clickup_delta_response.json 2>/dev/null; then
            echo "::error::‚ùå Invalid JSON response from ClickUp API"
            echo "Response content:"
            cat /tmp/clickup_delta_response.json
            exit 1
          fi

          echo "‚úÖ API Response received successfully"

          # Parse delta tasks and filter with explicit sorting
          DELTA_TASK_BRANCH_PAIRS=$(jq -r '.tasks[] | 
          select(
            .status.status == "delta" and 
            (.custom_fields[] | select(.name == "Repository") | .value) == "cp-web-next-test"
          ) | 
          (.custom_fields[] | select(.name == "Branch") | .value) as $branch |
          select($branch != null and $branch != "") |
          "\(.name)\t\($branch)\t\(.id)"' \
          /tmp/clickup_delta_response.json | sort)

          if [ -z "$DELTA_TASK_BRANCH_PAIRS" ]; then
            echo "‚ÑπÔ∏è No delta tasks found for cp-web-next-test repository"
            echo "has_delta_tasks=false" >> $GITHUB_OUTPUT
          else
            DELTA_TASK_COUNT=$(echo "$DELTA_TASK_BRANCH_PAIRS" | wc -l)
            echo "üéØ Found $DELTA_TASK_COUNT delta tasks for cp-web-next-test:"
            echo "$DELTA_TASK_BRANCH_PAIRS" | while IFS=$'\t' read -r task_name branch_name task_id; do
              echo "  üìã $task_name (Branch: $branch_name)"
            done
            echo "has_delta_tasks=true" >> $GITHUB_OUTPUT
            echo "delta_task_count=$DELTA_TASK_COUNT" >> $GITHUB_OUTPUT
            # Store the paired data in outputs for next step
            echo "delta_task_branch_pairs<<EOF" >> $GITHUB_OUTPUT
            echo "$DELTA_TASK_BRANCH_PAIRS" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Merge Delta Tasks
        id: merge_delta_tasks
        if: steps.fetch_delta_tasks.outputs.has_delta_tasks == 'true'
        run: |
          cleanup() {
            rm -f /tmp/delta_tasks_to_process.txt /tmp/clickup_delta_response.json
          }
          trap cleanup EXIT

          DELTA_BRANCH_NAME="${{ steps.create_delta_branch.outputs.delta_branch_name }}"
          TOTAL_DELTA_TASKS="${{ steps.fetch_delta_tasks.outputs.delta_task_count }}"
          DELTA_MERGED_COUNT=0
          DELTA_FAILED_TASKS=()

          echo "üöÄ Starting delta merge process for $TOTAL_DELTA_TASKS tasks..."

          # Enhanced cleanup function for git operations
          cleanup_git() {
            git merge --abort 2>/dev/null || true
            git clean -fd 2>/dev/null || true
          }

          # Checkout the delta branch
          if ! git checkout $DELTA_BRANCH_NAME; then
            echo "::error::‚ùå Failed to checkout delta branch $DELTA_BRANCH_NAME"
            exit 1
          fi

          # Get delta task-branch pairs from previous step output
          DELTA_TASK_BRANCH_PAIRS="${{ steps.fetch_delta_tasks.outputs.delta_task_branch_pairs }}"

          # Process each delta task-branch pair using temporary file to avoid subshell variable scope issues
          echo "$DELTA_TASK_BRANCH_PAIRS" > /tmp/delta_tasks_to_process.txt

          while IFS=$'\t' read -r task_name branch_name task_id; do
            if [ -n "$task_name" ] && [ -n "$branch_name" ]; then
              echo ""
              echo "üì¶ Processing delta task ($((DELTA_MERGED_COUNT + 1))/$TOTAL_DELTA_TASKS): $task_name"
              echo "   Branch: $branch_name"
              
              # Check if branch exists remotely
              if git ls-remote --exit-code --heads origin "$branch_name" >/dev/null 2>&1; then
                echo "‚úÖ Branch exists remotely"
                
                # Fetch the latest version of the branch
                if git fetch origin "$branch_name" 2>/dev/null; then
                  echo "üì• Fetched latest version"
                  
                  # Check if there are any changes to merge
                  if git merge-tree $(git merge-base HEAD "origin/$branch_name") HEAD "origin/$branch_name" | grep -q .; then
                    echo "üîÑ Changes detected, performing squash merge..."
                    
                    # Use squash merge to keep history clean
                    echo "üîß Executing: git merge origin/$branch_name --squash --no-edit"
                    if git merge "origin/$branch_name" --squash --no-edit; then
                      echo "üîç Checking for staged changes..."
                      # Check if there are changes to commit
                      if ! git diff --cached --quiet; then
                        if git commit -m "feat: merge delta $branch_name"; then
                          echo "‚úÖ Successfully squash merged delta $branch_name"
                          DELTA_MERGED_COUNT=$((DELTA_MERGED_COUNT + 1))
                        else
                          echo "‚ùå Failed to commit squash merge for delta $branch_name"
                          cleanup_git
                          DELTA_FAILED_TASKS+=("$task_name ($branch_name): Commit failed")
                        fi
                      else
                        echo "‚ÑπÔ∏è No changes to commit (already up to date)"
                        DELTA_MERGED_COUNT=$((DELTA_MERGED_COUNT + 1))
                      fi
                    else
                      echo "‚ùå Merge conflict detected for delta $branch_name"
                      echo "::error::Merge conflict detected for delta task: $task_name (branch: $branch_name)"
                      cleanup_git
                      DELTA_FAILED_TASKS+=("$task_name ($branch_name): Merge conflict")
                    fi
                  else
                    echo "‚ÑπÔ∏è No changes to merge (already up to date)"
                    DELTA_MERGED_COUNT=$((DELTA_MERGED_COUNT + 1))
                  fi
                else
                  echo "‚ùå Failed to fetch branch $branch_name"
                  DELTA_FAILED_TASKS+=("$task_name ($branch_name): Failed to fetch")
                fi
              else
                echo "‚ùå Branch $branch_name not found remotely"
                echo "::warning::Branch not found for delta task: $task_name"
                DELTA_FAILED_TASKS+=("$task_name ($branch_name): Branch not found")
              fi
            fi
          done < /tmp/delta_tasks_to_process.txt

          {
            echo "### Merge Delta Tasks Summary"
            echo "- Total delta tasks: $TOTAL_DELTA_TASKS"
            echo "- Successfully merged: $DELTA_MERGED_COUNT"
            echo "- Failed delta tasks: ${#DELTA_FAILED_TASKS[@]}"
            if [ ${#DELTA_FAILED_TASKS[@]} -gt 0 ]; then
              echo "- List of failed delta tasks:"
              for task in "${DELTA_FAILED_TASKS[@]}"; do
                echo "  - $task"
              done
            fi
          } >> "$GITHUB_STEP_SUMMARY"

          # Clean up temporary file
          rm -f /tmp/delta_tasks_to_process.txt

          # Generate delta merge summary
          echo ""
          echo "üìä Delta Merge Summary:"
          echo "   Total delta tasks: $TOTAL_DELTA_TASKS"
          echo "   Successfully merged: $DELTA_MERGED_COUNT"
          echo "   Failed: ${#DELTA_FAILED_TASKS[@]}"

          # Report failed delta tasks if any
          if [ ${#DELTA_FAILED_TASKS[@]} -gt 0 ]; then
            echo ""
            echo "‚ùå Failed delta tasks:"
            for task in "${DELTA_FAILED_TASKS[@]}"; do
              echo "   $task"
            done
            
            # Create summary for GitHub
            {
              echo "## Delta Merge Summary"
              echo ""
              echo "- ‚úÖ Successfully merged: $DELTA_MERGED_COUNT/$TOTAL_DELTA_TASKS delta tasks"
              echo "- ‚ùå Failed: ${#DELTA_FAILED_TASKS[@]} delta tasks"
              echo ""
              if [ ${#DELTA_FAILED_TASKS[@]} -gt 0 ]; then
                echo "### Failed Delta Tasks:"
                for task in "${DELTA_FAILED_TASKS[@]}"; do
                  echo "- $task"
                done
              fi
            } >> $GITHUB_STEP_SUMMARY
          fi

          # Push changes if any delta merges were successful
          if [ $DELTA_MERGED_COUNT -gt 0 ]; then
            echo ""
            echo "üì§ Pushing $DELTA_MERGED_COUNT successful delta merges..."
            if git push origin $DELTA_BRANCH_NAME; then
              echo "‚úÖ Successfully pushed all delta changes"
              echo "delta_merge_success=true" >> $GITHUB_OUTPUT
              echo "delta_merged_count=$DELTA_MERGED_COUNT" >> $GITHUB_OUTPUT
            else
              echo "::error::‚ùå Failed to push delta changes"
              exit 1
            fi
          else
            echo "‚ö†Ô∏è No delta changes to push"
            echo "delta_merge_success=false" >> $GITHUB_OUTPUT
            echo "delta_merged_count=0" >> $GITHUB_OUTPUT
          fi

          # Check if all delta tasks were successfully merged (perfect scenario)
          if [ $DELTA_MERGED_COUNT -eq $TOTAL_DELTA_TASKS ]; then
            echo "all_delta_tasks_merged=true" >> $GITHUB_OUTPUT
            echo "üéâ All delta tasks successfully merged!"
          else
            echo "all_delta_tasks_merged=false" >> $GITHUB_OUTPUT
          fi

          # Exit with error if some delta tasks failed but allow partial success
          if [ ${#DELTA_FAILED_TASKS[@]} -gt 0 ] && [ $DELTA_MERGED_COUNT -eq 0 ]; then
            echo "::error::‚ùå All delta merge operations failed"
            echo "delta_merge_success=false" >> $GITHUB_OUTPUT
            echo "delta_merged_count=0" >> $GITHUB_OUTPUT
            exit 1
          elif [ ${#DELTA_FAILED_TASKS[@]} -gt 0 ]; then
            echo "::warning::‚ö†Ô∏è Some delta tasks failed but $DELTA_MERGED_COUNT tasks were successfully merged"
            echo "delta_merge_success=true" >> $GITHUB_OUTPUT
            echo "delta_merged_count=$DELTA_MERGED_COUNT" >> $GITHUB_OUTPUT
          else
            echo "delta_merge_success=true" >> $GITHUB_OUTPUT
            echo "delta_merged_count=$DELTA_MERGED_COUNT" >> $GITHUB_OUTPUT
          fi

      - name: Handle Different Scenarios
        if: always()
        run: |
          BRANCH_EXISTS="${{ steps.create_branch.outputs.branch_exists }}"
          HAS_TASKS="${{ steps.fetch_tasks.outputs.has_tasks }}"
          MERGE_SUCCESS="${{ steps.merge_beta_tasks.outputs.merge_success }}"
          MERGED_COUNT="${{ steps.merge_beta_tasks.outputs.merged_count }}"
          ALL_TASKS_MERGED="${{ steps.merge_beta_tasks.outputs.all_tasks_merged }}"
          DELTA_CREATED="${{ steps.create_delta_branch.outputs.delta_branch_created }}"
          DELTA_EXISTS="${{ steps.create_delta_branch.outputs.delta_branch_exists }}"
          HAS_DELTA_TASKS="${{ steps.fetch_delta_tasks.outputs.has_delta_tasks }}"
          DELTA_MERGE_SUCCESS="${{ steps.merge_delta_tasks.outputs.delta_merge_success }}"
          DELTA_MERGED_COUNT="${{ steps.merge_delta_tasks.outputs.delta_merged_count }}"
          ALL_DELTA_TASKS_MERGED="${{ steps.merge_delta_tasks.outputs.all_delta_tasks_merged }}"

          echo "üìã Final Status Summary:"
          echo "   Branch exists: $BRANCH_EXISTS"
          echo "   Has tasks: $HAS_TASKS"
          echo "   Merge success: $MERGE_SUCCESS"
          echo "   Merged count: $MERGED_COUNT"
          echo "   All tasks merged: $ALL_TASKS_MERGED"
          echo "   Delta created: $DELTA_CREATED"
          echo "   Delta exists: $DELTA_EXISTS"
          echo "   Has delta tasks: $HAS_DELTA_TASKS"
          echo "   Delta merge success: $DELTA_MERGE_SUCCESS"
          echo "   Delta merged count: $DELTA_MERGED_COUNT"
          echo "   All delta tasks merged: $ALL_DELTA_TASKS_MERGED"

          # Generate final summary
          {
            echo "## Weekly Beta Branch Creation Summary"
            echo ""
            echo "**Beta Branch:** \`${{ steps.create_branch.outputs.branch_name }}\`"
            
            if [ "$DELTA_CREATED" = "true" ] || [ "$DELTA_EXISTS" = "true" ]; then
              DELTA_BRANCH_NAME="${{ steps.create_delta_branch.outputs.delta_branch_name }}"
              echo "**Delta Branch:** \`$DELTA_BRANCH_NAME\`"
            fi
            
            echo ""
            
            if [ "$BRANCH_EXISTS" = "true" ] && [ "$HAS_TASKS" = "false" ]; then
              echo "‚úÖ **Status:** Branch already exists, no new tasks to merge (normal situation)"
            elif [ "$BRANCH_EXISTS" = "false" ] && [ "$HAS_TASKS" = "false" ]; then
              echo "‚úÖ **Status:** New branch created, no tasks found (normal situation)"
            elif [ "$HAS_TASKS" = "true" ] && [ "$ALL_TASKS_MERGED" = "true" ] && [ "$DELTA_CREATED" = "true" ]; then
              echo "üéâ **Status:** Perfect! All $MERGED_COUNT beta tasks merged successfully, delta branch created"
            elif [ "$HAS_TASKS" = "true" ] && [ "$ALL_TASKS_MERGED" = "true" ] && [ "$DELTA_EXISTS" = "true" ]; then
              echo "‚úÖ **Status:** All $MERGED_COUNT beta tasks merged successfully, delta branch already exists"
            elif [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "true" ]; then
              echo "‚ö†Ô∏è **Status:** Partially successful - $MERGED_COUNT beta tasks merged (some failed, delta not created)"
            elif [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "false" ]; then
              echo "‚ùå **Status:** Beta task merge failed"
            else
              echo "‚ÑπÔ∏è **Status:** Workflow completed"
            fi
            
            # Add delta task summary if applicable
            if [ "$HAS_DELTA_TASKS" = "true" ]; then
              echo ""
              echo "### Delta Tasks Summary"
              if [ "$ALL_DELTA_TASKS_MERGED" = "true" ]; then
                echo "üéâ **Delta Status:** All $DELTA_MERGED_COUNT delta tasks merged successfully!"
              elif [ "$DELTA_MERGE_SUCCESS" = "true" ]; then
                echo "‚ö†Ô∏è **Delta Status:** Partially successful - $DELTA_MERGED_COUNT delta tasks merged (some failed)"
              else
                echo "‚ùå **Delta Status:** Delta task merge failed"
              fi
            fi
            
            echo ""
            echo "**Timestamp:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
          } >> $GITHUB_STEP_SUMMARY

          # Only exit with error for actual failures, not expected scenarios
          if [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "false" ] && [ "${MERGED_COUNT:-0}" = "0" ]; then
            echo "::error::‚ùå Workflow failed due to beta merge issues"
            exit 1
          elif [ "$HAS_DELTA_TASKS" = "true" ] && [ "$DELTA_MERGE_SUCCESS" = "false" ] && [ "${DELTA_MERGED_COUNT:-0}" = "0" ]; then
            echo "::error::‚ùå Workflow failed due to delta merge issues"
            exit 1
          elif [ "$HAS_TASKS" = "true" ] && [ "$MERGE_SUCCESS" = "true" ]; then
            echo "‚úÖ Workflow completed successfully with $MERGED_COUNT beta tasks merged"
            if [ "$ALL_TASKS_MERGED" = "true" ] && [ "$DELTA_CREATED" = "true" ]; then
              echo "üéâ Bonus: Delta branch created for deployment!"
            fi
            if [ "$HAS_DELTA_TASKS" = "true" ] && [ "$DELTA_MERGE_SUCCESS" = "true" ]; then
              echo "üéâ Bonus: $DELTA_MERGED_COUNT delta tasks merged!"
            fi
            exit 0
          elif [ "$HAS_DELTA_TASKS" = "true" ] && [ "$DELTA_MERGE_SUCCESS" = "true" ]; then
            echo "‚úÖ Workflow completed successfully with $DELTA_MERGED_COUNT delta tasks merged"
            exit 0
          else
            echo "‚úÖ Workflow completed successfully (no tasks to merge)"
            exit 0
          fi
